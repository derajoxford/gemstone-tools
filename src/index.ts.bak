import 'dotenv/config';
import {
  Client, GatewayIntentBits, Routes, Partials, REST, ModalBuilder, TextInputBuilder,
  TextInputStyle, ActionRowBuilder, SlashCommandBuilder, ChatInputCommandInteraction,
  EmbedBuilder, Colors, PermissionFlagsBits
} from 'discord.js';
import pino from 'pino';
import cron from 'node-cron';
import { PrismaClient, WithdrawStatus } from '@prisma/client';
import { seal, open } from './lib/crypto.js';
import { RES_EMOJI, ORDER } from './lib/emojis.js';
import { fetchBankrecs } from './lib/pnw.js';

const log = pino({ level: 'info' });
const prisma = new PrismaClient();

const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMembers],
  partials: [Partials.GuildMember]
});

// --- Slash command registration (global) ---
const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN!);
const commands = [
  new SlashCommandBuilder().setName('setup_alliance')
    .setDescription('Link this Discord to a PnW Alliance banking setup')
    .addIntegerOption(o=>o.setName('alliance_id').setDescription('PnW Alliance ID').setRequired(true))
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild),

  new SlashCommandBuilder().setName('link_nation')
    .setDescription('Link your Discord to your PnW nation for safekeeping')
    .addIntegerOption(o=>o.setName('nation_id').setDescription('Your nation id').setRequired(true))
    .addStringOption(o=>o.setName('nation_name').setDescription('Your nation name').setRequired(true)),

  new SlashCommandBuilder().setName('balance')
    .setDescription('Show your safekeeping balance'),

  new SlashCommandBuilder().setName('withdraw')
    .setDescription('Request a withdrawal from your safekeeping')
    .addStringOption(o=>o.setName('payload').setDescription('JSON of resources {money:1000000, steel:500}').setRequired(true)),

  // --- banker review commands (Manage Server permission) ---
  new SlashCommandBuilder().setName('withdraw_list')
    .setDescription('List recent withdrawal requests (default: PENDING)')
    .addStringOption(o =>
      o.setName('status')
       .setDescription('Filter by status')
       .addChoices(
         { name: 'PENDING', value: 'PENDING' },
         { name: 'APPROVED', value: 'APPROVED' },
         { name: 'REJECTED', value: 'REJECTED' },
         { name: 'PAID', value: 'PAID' },
         { name: 'CANCELED', value: 'CANCELED' }
       )
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild),

  new SlashCommandBuilder().setName('withdraw_set')
    .setDescription('Set the status of a withdrawal request')
    .addStringOption(o=>o.setName('id').setDescription('Request ID (UUID)').setRequired(true))
    .addStringOption(o =>
      o.setName('status')
       .setDescription('New status')
       .setRequired(true)
       .addChoices(
         { name: 'APPROVED', value: 'APPROVED' },
         { name: 'REJECTED', value: 'REJECTED' },
         { name: 'PAID', value: 'PAID' },
         { name: 'CANCELED', value: 'CANCELED' }
       )
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.ManageGuild),
].map(c => c.toJSON());

async function register() {
  const appId = process.env.DISCORD_CLIENT_ID!;
  try {
    await rest.put(Routes.applicationCommands(appId), { body: commands });
    log.info('Slash commands registered');
  } catch (e) {
    log.error(e);
  }
}

client.once('ready', async () => {
  log.info({ tag: client.user?.tag }, 'Gemstone Tools online ‚ú®');
  await register();
});

client.on('interactionCreate', async (i) => {
  if (!i.isChatInputCommand()) return;
  try {
    if (i.commandName === 'setup_alliance') return handleSetupAlliance(i);
    if (i.commandName === 'link_nation') return handleLinkNation(i);
    if (i.commandName === 'balance') return handleBalance(i);
    if (i.commandName === 'withdraw') return handleWithdraw(i);
    if (i.commandName === 'withdraw_list') return handleWithdrawList(i);
    if (i.commandName === 'withdraw_set') return handleWithdrawSet(i);
  } catch (err) {
    console.error(err);
    if (i.isRepliable()) await i.reply({ content: 'Something went wrong.', ephemeral: true });
  }
});

// --- handlers ---
async function handleSetupAlliance(i: ChatInputCommandInteraction) {
  const allianceId = i.options.getInteger('alliance_id', true);
  const modal = new ModalBuilder().setCustomId(`alliancekeys:${allianceId}`).setTitle('Alliance API Key');
  const api = new TextInputBuilder()
    .setCustomId('apiKey')
    .setLabel('Alliance API Key')
    .setStyle(TextInputStyle.Short)
    .setRequired(true);
  modal.addComponents(new ActionRowBuilder<TextInputBuilder>().addComponents(api));
  await i.showModal(modal);
}

client.on('interactionCreate', async (i) => {
  if (!i.isModalSubmit()) return;
  if (!i.customId.startsWith('alliancekeys:')) return;
  const allianceId = parseInt(i.customId.split(':')[1]!, 10);
  const apiKey = i.fields.getTextInputValue('apiKey');
  const { ciphertext: encApi, iv: ivApi } = seal(apiKey);
  await prisma.alliance.upsert({
    where: { id: allianceId },
    update: { guildId: i.guildId ?? undefined },
    create: { id: allianceId, guildId: i.guildId ?? undefined }
  });
  await prisma.allianceKey.create({ data: {
    allianceId,
    encryptedApiKey: encApi,
    nonceApi: ivApi,
    addedBy: i.user.id
  }});
  await i.reply({ content: `‚úÖ API key saved for alliance ${allianceId}.`, ephemeral: true });
});

async function handleLinkNation(i: ChatInputCommandInteraction) {
  const nationId = i.options.getInteger('nation_id', true);
  const nationName = i.options.getString('nation_name', true);
  const alliance = await prisma.alliance.findFirst({ where: { guildId: i.guildId ?? '' } });
  if (!alliance) return i.reply({ content: 'This server is not linked to an alliance yet. Run /setup_alliance first.', ephemeral: true });

  await prisma.member.upsert({
    where: { allianceId_discordId: { allianceId: alliance.id, discordId: i.user.id } },
    update: { nationId, nationName },
    create: { allianceId: alliance.id, discordId: i.user.id, nationId, nationName }
  });

  const member = await prisma.member.findFirstOrThrow({ where: { allianceId: alliance.id, discordId: i.user.id } });
  await prisma.safekeeping.upsert({ where: { memberId: member.id }, update: {}, create: { memberId: member.id } });

  await i.reply({ content: 'üîó Nation linked for safekeeping.', ephemeral: true });
}

async function handleBalance(i: ChatInputCommandInteraction) {
  const alliance = await prisma.alliance.findFirst({ where: { guildId: i.guildId ?? '' } });
  if (!alliance) return i.reply({ content: 'No alliance linked to this server yet.', ephemeral: true });
  const member = await prisma.member.findFirst({ where: { allianceId: alliance.id, discordId: i.user.id }, include: { balance: true } });
  if (!member || !member.balance) return i.reply({ content: 'No safekeeping account found. Run /link_nation first.', ephemeral: true });

  const bal: any = member.balance as any;
  const lines = ORDER.map(k => {
    const v = Number((bal as any)[k] || 0);
    return v ? `${RES_EMOJI[k]} **${k}**: ${v.toLocaleString()}` : undefined;
  }).filter(Boolean);

  const embed = new EmbedBuilder()
    .setTitle('üíé Gemstone Safekeeping')
    .setDescription(lines.join('\n') || 'No resources held.')
    .setFooter({ text: `Nation: ${member.nationName} (${member.nationId})` })
    .setColor(Colors.Blurple);

  await i.reply({ embeds: [embed], ephemeral: true });
}

async function handleWithdraw(i: ChatInputCommandInteraction) {
  const payloadRaw = i.options.getString('payload', true);
  const alliance = await prisma.alliance.findFirst({ where: { guildId: i.guildId ?? '' } });
  if (!alliance) return i.reply({ content: 'No alliance linked to this server yet.', ephemeral: true });
  const member = await prisma.member.findFirst({ where: { allianceId: alliance.id, discordId: i.user.id } });
  if (!member) return i.reply({ content: 'Link your nation first with /link_nation.', ephemeral: true });

  let payload: any;
  try { payload = JSON.parse(payloadRaw); }
  catch { return i.reply({ content: 'Invalid JSON.', ephemeral: true }); }

  const req = await prisma.withdrawalRequest.create({ data: {
    allianceId: alliance.id,
    memberId: member.id,
    payload,
    createdBy: i.user.id
  }});

  const embed = new EmbedBuilder()
    .setTitle('üí∏ Withdrawal Request')
    .setDescription(`Request **${req.id}** from <@${i.user.id}>`)
    .addFields(
      Object.entries(payload).map(([k,v]) => ({ name: `${RES_EMOJI[k]||''} ${k}`, value: String(v), inline: true }))
    )
    .setColor(Colors.Gold);

  await i.reply({ content: '‚úÖ Request submitted for review by bankers.', ephemeral: true });
  const ch = await client.channels.fetch(i.channelId);
  if (ch && ch.isTextBased()) {
    await ch.send({ embeds: [embed] });
  }
}

// --- banker review handlers ---
async function handleWithdrawList(i: ChatInputCommandInteraction) {
  const alliance = await prisma.alliance.findFirst({ where: { guildId: i.guildId ?? '' } });
  if (!alliance) return i.reply({ content: 'No alliance linked here.', ephemeral: true });

  const statusStr = i.options.getString('status') as WithdrawStatus | null;
  const status = statusStr ?? 'PENDING';

  const rows = await prisma.withdrawalRequest.findMany({
    where: { allianceId: alliance.id, status },
    orderBy: { createdAt: 'desc' },
    take: 10
  });

  if (!rows.length) return i.reply({ content: `No ${status} requests.`, ephemeral: true });

  const embed = new EmbedBuilder()
    .setTitle(`üìú Withdrawal Requests ‚Äî ${status}`)
    .setColor(status === 'PENDING' ? Colors.Yellow : status === 'APPROVED' ? Colors.Green : status === 'REJECTED' ? Colors.Red : Colors.Greyple);

  for (const r of rows) {
    const maker = `<@${r.createdBy}>`;
    const fields = Object.entries(r.payload as any).map(([k,v]) => `${RES_EMOJI[k]||''} ${k}: ${v}`).join(' ¬∑ ');
    embed.addFields({ name: r.id, value: `${maker}\n${fields}`, inline: false });
  }

  await i.reply({ embeds: [embed], ephemeral: true });
}

async function handleWithdrawSet(i: ChatInputCommandInteraction) {
  const alliance = await prisma.alliance.findFirst({ where: { guildId: i.guildId ?? '' } });
  if (!alliance) return i.reply({ content: 'No alliance linked here.', ephemeral: true });

  const id = i.options.getString('id', true);
  const status = i.options.getString('status', true) as WithdrawStatus;

  try {
    const updated = await prisma.withdrawalRequest.update({
      where: { id },
      data: { status, reviewerId: i.user.id }
    });

    const color = status === 'APPROVED' ? Colors.Green
      : status === 'REJECTED' ? Colors.Red
      : status === 'PAID' ? Colors.Blue
      : Colors.Greyple;

    const embed = new EmbedBuilder()
      .setTitle('üõ†Ô∏è Withdrawal Status Updated')
      .setDescription(`Request **${updated.id}** ‚Üí **${status}** by <@${i.user.id}>`)
      .setColor(color);

    await i.reply({ embeds: [embed], ephemeral: true });
  } catch {
    await i.reply({ content: 'Could not update. Check the ID.', ephemeral: true });
  }
}

// --- CRON: bank monitor (every 2 minutes) ---
cron.schedule('*/2 * * * *', async () => {
  const toInt = (v:any) => Number.parseInt(String(v), 10) || 0;
  const toNum = (v:any) => Number.parseFloat(String(v)) || 0;

  const alliances = await prisma.alliance.findMany({ include: { keys: { orderBy: { id: 'desc' }, take: 1 } } });
  for (const a of alliances) {
    try {
      const k = a.keys[0];
      const apiKey = k ? open(k.encryptedApiKey as any, k.nonceApi as any) : (process.env.PNW_DEFAULT_API_KEY||'');
      if (!apiKey) continue;

      const alliancesData = await fetchBankrecs({ apiKey }, [a.id]);
      const al = alliancesData[0];
      if (!al || !al.bankrecs) continue;

      let last = a.lastBankrecId || 0;
      const rows = (al.bankrecs as any[]).filter(r => toInt(r.id) > last).sort((x:any,y:any)=>toInt(x.id)-toInt(y.id));
      for (const r of rows) {
        await prisma.bankrec.upsert({
          where: { id: toInt(r.id) },
          update: {},
          create: {
            id: toInt(r.id),
            allianceId: a.id,
            date: new Date(r.date),
            note: r.note || null,
            senderType: toInt(r.sender_type),
            senderId: toInt(r.sender_id),
            receiverType: toInt(r.receiver_type),
            receiverId: toInt(r.receiver_id),
            money: toNum(r.money),
            food: toNum(r.food),
            coal: toNum(r.coal),
            oil: toNum(r.oil),
            uranium: toNum(r.uranium),
            lead: toNum(r.lead),
            iron: toNum(r.iron),
            bauxite: toNum(r.bauxite),
            gasoline: toNum(r.gasoline),
            munitions: toNum(r.munitions),
            steel: toNum(r.steel),
            aluminum: toNum(r.aluminum),
          }
        });

        const isDeposit = toInt(r.sender_type) === 1 && toInt(r.receiver_type) === 2 && toInt(r.receiver_id) === a.id;
        if (isDeposit) {
          const member = await prisma.member.findFirst({ where: { allianceId: a.id, nationId: toInt(r.sender_id) } });
          if (member) {
            await prisma.safekeeping.upsert({
              where: { memberId: member.id },
              update: {
                money: { increment: toNum(r.money) },
                food: { increment: toNum(r.food) },
                coal: { increment: toNum(r.coal) },
                oil: { increment: toNum(r.oil) },
                uranium: { increment: toNum(r.uranium) },
                lead: { increment: toNum(r.lead) },
                iron: { increment: toNum(r.iron) },
                bauxite: { increment: toNum(r.bauxite) },
                gasoline: { increment: toNum(r.gasoline) },
                munitions: { increment: toNum(r.munitions) },
                steel: { increment: toNum(r.steel) },
                aluminum: { increment: toNum(r.aluminum) },
              },
              create: { memberId: member.id }
            });

            try {
              const user = await client.users.fetch(member.discordId);
              await user.send(`üíé Deposit credited to your safekeeping. Note: ${r.note||''}`);
            } catch {}
          }
        }
        last = Math.max(last, Number(r.id));
      }

      if (last && last !== (a.lastBankrecId||0)) {
        await prisma.alliance.update({ where: { id: a.id }, data: { lastBankrecId: last } });
      }
    } catch (err) {
      log.error({ err }, 'bank monitor failed for alliance');
    }
  }
});

client.login(process.env.DISCORD_TOKEN);
