generator client {
  provider = "prisma-client-js"
}datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}model Alliance {
  id              Int             @id
  guildId         String?
  name            String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  lastBankrecId   Int?
  reviewChannelId String?
  logChannelId    String?
  AllianceConfig  AllianceConfig?
  keys            AllianceKey[] @relation(name: "AllianceKeysOnAlliance")
  bankrecs        Bankrec[]
  members         Member[]
  treasury      AllianceTreasury? @relation(name: "AllianceTreasuryOnAlliance")
  ledgerEntries LedgerEntry[]     @relation(name: "LedgerAlliance")}model AllianceKey {
  id              Int      @id @default(autoincrement())
  allianceId      Int
  encryptedApiKey Bytes
  encryptedBotKey Bytes?
  nonceApi        Bytes
  nonceBot        Bytes?
  addedBy         String
  createdAt       DateTime @default(now())
  alliance   Alliance @relation(name: "AllianceKeysOnAlliance", fields: [allianceId], references: [id])
}model Member {
  id         Int          @id @default(autoincrement())
  allianceId Int
  discordId  String
  nationId   Int
  nationName String
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  alliance   Alliance     @relation(fields: [allianceId], references: [id])
  balance    Safekeeping?  @@unique([allianceId, discordId])
}model Safekeeping {
  id        Int      @id @default(autoincrement())
  memberId  Int      @unique
  money     Decimal  @default(0)
  food      Decimal  @default(0)
  coal      Decimal  @default(0)
  oil       Decimal  @default(0)
  uranium   Decimal  @default(0)
  lead      Decimal  @default(0)
  iron      Decimal  @default(0)
  bauxite   Decimal  @default(0)
  gasoline  Decimal  @default(0)
  munitions Decimal  @default(0)
  steel     Decimal  @default(0)
  aluminum  Decimal  @default(0)
  updatedAt DateTime @updatedAt
  member    Member   @relation(fields: [memberId], references: [id])
  ledgerEntries LedgerEntry[] @relation(name: "LedgerMember")
}model Bankrec {
  id           Int      @id
  allianceId   Int
  date         DateTime
  note         String?
  senderType   Int
  senderId     Int
  receiverType Int
  receiverId   Int
  money        Decimal  @default(0)
  food         Decimal  @default(0)
  coal         Decimal  @default(0)
  oil          Decimal  @default(0)
  uranium      Decimal  @default(0)
  lead         Decimal  @default(0)
  iron         Decimal  @default(0)
  bauxite      Decimal  @default(0)
  gasoline     Decimal  @default(0)
  munitions    Decimal  @default(0)
  steel        Decimal  @default(0)
  aluminum     Decimal  @default(0)
  alliance     Alliance @relation(fields: [allianceId], references: [id])
  ledgerEntries LedgerEntry[] @relation(name: "LedgerMember")
}model WithdrawalRequest {
  id          String         @id @default(uuid())
  allianceId  Int
  memberId    Int
  status      WithdrawStatus @default(PENDING)
  payload     Json
  createdBy   String
  reviewerId  String?
  bankrecPaid Int?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
}model AllianceConfig {
  allianceId     Int      @id
  reviewerRoleId String?
  autopayEnabled Boolean  @default(true)
  maxMoney       Float?
  maxFood        Float?
  maxCoal        Float?
  maxOil         Float?
  maxUranium     Float?
  maxIron        Float?
  maxBauxite     Float?
  maxLead        Float?
  maxGasoline    Float?
  maxMunitions   Float?
  maxSteel       Float?
  maxAluminum    Float?
  createdAt      DateTime @default(now())
  updatedAt      DateTime
  logChannelId   String?
  Alliance       Alliance @relation(fields: [allianceId], references: [id])
}enum WithdrawStatus {
  PENDING
  APPROVED
  REJECTED
  PAID
  CANCELED
}model Setting {
  id         String   @id @default(cuid())
  guildId    String
  key        String
  value      String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt  @@unique([guildId, key], name: "guildId_key")
}/// --- Gemstone Tools: Alliance Treasury & Ledger ---
/// JSON-based balances to avoid schema churn for new resources.
enum AccountScope {
  ALLIANCE
  SAFEKEEPING
}enum EntryKind {
  DEPOSIT
  WITHDRAW
  TRANSFER
  ADJUST
}model AllianceTreasury {
  id         String   @id @default(cuid())
  allianceId Int      @unique
  alliance   Alliance @relation(name: "AllianceTreasuryOnAlliance", fields: [allianceId], references: [id])  /// JSON object like: {"money": 123456, "steel": 50}
  balances   Json     @default("{}")  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt  @@index([allianceId])
}model LedgerEntry {
  id             String       @id @default(cuid())
  allianceId     Int
  alliance       Alliance @relation(name: "LedgerAlliance", fields: [allianceId], references: [id])  /// Optional member context for safekeeping entries
  memberId       Int?
  member         Member? @relation(name: "LedgerMember", fields: [memberId], references: [id])  scope          AccountScope
  kind           EntryKind  /// JSON amounts; ex: {"money": 5000} (positive/negative deltas allowed)
  amounts        Json
  note           String?  /// Who performed the action in Discord (if applicable)
  actorDiscordId String?  /// Source bankrec id (if from PnW polling)
  bankrecId      Int?  createdAt      DateTime     @default(now())  @@index([allianceId, createdAt])
  @@index([scope, createdAt])
}